// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'package_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$PackageEventTearOff {
  const _$PackageEventTearOff();

// ignore: unused_element
  _PackageEventInit init() {
    return const _PackageEventInit();
  }

// ignore: unused_element
  _PackageEventRefresh refresh() {
    return const _PackageEventRefresh();
  }

// ignore: unused_element
  _PackageEventImpulse impulse(String uuid) {
    return _PackageEventImpulse(
      uuid,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $PackageEvent = _$PackageEventTearOff();

/// @nodoc
mixin _$PackageEvent {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result refresh(),
    @required Result impulse(String uuid),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result refresh(),
    Result impulse(String uuid),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageEventInit value),
    @required Result refresh(_PackageEventRefresh value),
    @required Result impulse(_PackageEventImpulse value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageEventInit value),
    Result refresh(_PackageEventRefresh value),
    Result impulse(_PackageEventImpulse value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $PackageEventCopyWith<$Res> {
  factory $PackageEventCopyWith(
          PackageEvent value, $Res Function(PackageEvent) then) =
      _$PackageEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$PackageEventCopyWithImpl<$Res> implements $PackageEventCopyWith<$Res> {
  _$PackageEventCopyWithImpl(this._value, this._then);

  final PackageEvent _value;
  // ignore: unused_field
  final $Res Function(PackageEvent) _then;
}

/// @nodoc
abstract class _$PackageEventInitCopyWith<$Res> {
  factory _$PackageEventInitCopyWith(
          _PackageEventInit value, $Res Function(_PackageEventInit) then) =
      __$PackageEventInitCopyWithImpl<$Res>;
}

/// @nodoc
class __$PackageEventInitCopyWithImpl<$Res>
    extends _$PackageEventCopyWithImpl<$Res>
    implements _$PackageEventInitCopyWith<$Res> {
  __$PackageEventInitCopyWithImpl(
      _PackageEventInit _value, $Res Function(_PackageEventInit) _then)
      : super(_value, (v) => _then(v as _PackageEventInit));

  @override
  _PackageEventInit get _value => super._value as _PackageEventInit;
}

/// @nodoc
class _$_PackageEventInit
    with DiagnosticableTreeMixin
    implements _PackageEventInit {
  const _$_PackageEventInit();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageEvent.init()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'PackageEvent.init'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PackageEventInit);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result refresh(),
    @required Result impulse(String uuid),
  }) {
    assert(init != null);
    assert(refresh != null);
    assert(impulse != null);
    return init();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result refresh(),
    Result impulse(String uuid),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageEventInit value),
    @required Result refresh(_PackageEventRefresh value),
    @required Result impulse(_PackageEventImpulse value),
  }) {
    assert(init != null);
    assert(refresh != null);
    assert(impulse != null);
    return init(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageEventInit value),
    Result refresh(_PackageEventRefresh value),
    Result impulse(_PackageEventImpulse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _PackageEventInit implements PackageEvent {
  const factory _PackageEventInit() = _$_PackageEventInit;
}

/// @nodoc
abstract class _$PackageEventRefreshCopyWith<$Res> {
  factory _$PackageEventRefreshCopyWith(_PackageEventRefresh value,
          $Res Function(_PackageEventRefresh) then) =
      __$PackageEventRefreshCopyWithImpl<$Res>;
}

/// @nodoc
class __$PackageEventRefreshCopyWithImpl<$Res>
    extends _$PackageEventCopyWithImpl<$Res>
    implements _$PackageEventRefreshCopyWith<$Res> {
  __$PackageEventRefreshCopyWithImpl(
      _PackageEventRefresh _value, $Res Function(_PackageEventRefresh) _then)
      : super(_value, (v) => _then(v as _PackageEventRefresh));

  @override
  _PackageEventRefresh get _value => super._value as _PackageEventRefresh;
}

/// @nodoc
class _$_PackageEventRefresh
    with DiagnosticableTreeMixin
    implements _PackageEventRefresh {
  const _$_PackageEventRefresh();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageEvent.refresh()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'PackageEvent.refresh'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PackageEventRefresh);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result refresh(),
    @required Result impulse(String uuid),
  }) {
    assert(init != null);
    assert(refresh != null);
    assert(impulse != null);
    return refresh();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result refresh(),
    Result impulse(String uuid),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (refresh != null) {
      return refresh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageEventInit value),
    @required Result refresh(_PackageEventRefresh value),
    @required Result impulse(_PackageEventImpulse value),
  }) {
    assert(init != null);
    assert(refresh != null);
    assert(impulse != null);
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageEventInit value),
    Result refresh(_PackageEventRefresh value),
    Result impulse(_PackageEventImpulse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class _PackageEventRefresh implements PackageEvent {
  const factory _PackageEventRefresh() = _$_PackageEventRefresh;
}

/// @nodoc
abstract class _$PackageEventImpulseCopyWith<$Res> {
  factory _$PackageEventImpulseCopyWith(_PackageEventImpulse value,
          $Res Function(_PackageEventImpulse) then) =
      __$PackageEventImpulseCopyWithImpl<$Res>;
  $Res call({String uuid});
}

/// @nodoc
class __$PackageEventImpulseCopyWithImpl<$Res>
    extends _$PackageEventCopyWithImpl<$Res>
    implements _$PackageEventImpulseCopyWith<$Res> {
  __$PackageEventImpulseCopyWithImpl(
      _PackageEventImpulse _value, $Res Function(_PackageEventImpulse) _then)
      : super(_value, (v) => _then(v as _PackageEventImpulse));

  @override
  _PackageEventImpulse get _value => super._value as _PackageEventImpulse;

  @override
  $Res call({
    Object uuid = freezed,
  }) {
    return _then(_PackageEventImpulse(
      uuid == freezed ? _value.uuid : uuid as String,
    ));
  }
}

/// @nodoc
class _$_PackageEventImpulse
    with DiagnosticableTreeMixin
    implements _PackageEventImpulse {
  const _$_PackageEventImpulse(this.uuid) : assert(uuid != null);

  @override
  final String uuid;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageEvent.impulse(uuid: $uuid)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PackageEvent.impulse'))
      ..add(DiagnosticsProperty('uuid', uuid));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PackageEventImpulse &&
            (identical(other.uuid, uuid) ||
                const DeepCollectionEquality().equals(other.uuid, uuid)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(uuid);

  @override
  _$PackageEventImpulseCopyWith<_PackageEventImpulse> get copyWith =>
      __$PackageEventImpulseCopyWithImpl<_PackageEventImpulse>(
          this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result refresh(),
    @required Result impulse(String uuid),
  }) {
    assert(init != null);
    assert(refresh != null);
    assert(impulse != null);
    return impulse(uuid);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result refresh(),
    Result impulse(String uuid),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (impulse != null) {
      return impulse(uuid);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageEventInit value),
    @required Result refresh(_PackageEventRefresh value),
    @required Result impulse(_PackageEventImpulse value),
  }) {
    assert(init != null);
    assert(refresh != null);
    assert(impulse != null);
    return impulse(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageEventInit value),
    Result refresh(_PackageEventRefresh value),
    Result impulse(_PackageEventImpulse value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (impulse != null) {
      return impulse(this);
    }
    return orElse();
  }
}

abstract class _PackageEventImpulse implements PackageEvent {
  const factory _PackageEventImpulse(String uuid) = _$_PackageEventImpulse;

  String get uuid;
  _$PackageEventImpulseCopyWith<_PackageEventImpulse> get copyWith;
}

/// @nodoc
class _$PackageStateTearOff {
  const _$PackageStateTearOff();

// ignore: unused_element
  _PackageStateInit init() {
    return const _PackageStateInit();
  }

// ignore: unused_element
  PackageStateLoading loading() {
    return const PackageStateLoading();
  }

// ignore: unused_element
  PackageStateLoaded loaded(PackagesResponse response) {
    return PackageStateLoaded(
      response,
    );
  }

// ignore: unused_element
  PackageStateError error(String s) {
    return PackageStateError(
      s,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $PackageState = _$PackageStateTearOff();

/// @nodoc
mixin _$PackageState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result loading(),
    @required Result loaded(PackagesResponse response),
    @required Result error(String s),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result loading(),
    Result loaded(PackagesResponse response),
    Result error(String s),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageStateInit value),
    @required Result loading(PackageStateLoading value),
    @required Result loaded(PackageStateLoaded value),
    @required Result error(PackageStateError value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageStateInit value),
    Result loading(PackageStateLoading value),
    Result loaded(PackageStateLoaded value),
    Result error(PackageStateError value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $PackageStateCopyWith<$Res> {
  factory $PackageStateCopyWith(
          PackageState value, $Res Function(PackageState) then) =
      _$PackageStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$PackageStateCopyWithImpl<$Res> implements $PackageStateCopyWith<$Res> {
  _$PackageStateCopyWithImpl(this._value, this._then);

  final PackageState _value;
  // ignore: unused_field
  final $Res Function(PackageState) _then;
}

/// @nodoc
abstract class _$PackageStateInitCopyWith<$Res> {
  factory _$PackageStateInitCopyWith(
          _PackageStateInit value, $Res Function(_PackageStateInit) then) =
      __$PackageStateInitCopyWithImpl<$Res>;
}

/// @nodoc
class __$PackageStateInitCopyWithImpl<$Res>
    extends _$PackageStateCopyWithImpl<$Res>
    implements _$PackageStateInitCopyWith<$Res> {
  __$PackageStateInitCopyWithImpl(
      _PackageStateInit _value, $Res Function(_PackageStateInit) _then)
      : super(_value, (v) => _then(v as _PackageStateInit));

  @override
  _PackageStateInit get _value => super._value as _PackageStateInit;
}

/// @nodoc
class _$_PackageStateInit
    with DiagnosticableTreeMixin
    implements _PackageStateInit {
  const _$_PackageStateInit();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageState.init()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'PackageState.init'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PackageStateInit);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result loading(),
    @required Result loaded(PackagesResponse response),
    @required Result error(String s),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return init();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result loading(),
    Result loaded(PackagesResponse response),
    Result error(String s),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageStateInit value),
    @required Result loading(PackageStateLoading value),
    @required Result loaded(PackageStateLoaded value),
    @required Result error(PackageStateError value),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return init(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageStateInit value),
    Result loading(PackageStateLoading value),
    Result loaded(PackageStateLoaded value),
    Result error(PackageStateError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class _PackageStateInit implements PackageState {
  const factory _PackageStateInit() = _$_PackageStateInit;
}

/// @nodoc
abstract class $PackageStateLoadingCopyWith<$Res> {
  factory $PackageStateLoadingCopyWith(
          PackageStateLoading value, $Res Function(PackageStateLoading) then) =
      _$PackageStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$PackageStateLoadingCopyWithImpl<$Res>
    extends _$PackageStateCopyWithImpl<$Res>
    implements $PackageStateLoadingCopyWith<$Res> {
  _$PackageStateLoadingCopyWithImpl(
      PackageStateLoading _value, $Res Function(PackageStateLoading) _then)
      : super(_value, (v) => _then(v as PackageStateLoading));

  @override
  PackageStateLoading get _value => super._value as PackageStateLoading;
}

/// @nodoc
class _$PackageStateLoading
    with DiagnosticableTreeMixin
    implements PackageStateLoading {
  const _$PackageStateLoading();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageState.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'PackageState.loading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is PackageStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result loading(),
    @required Result loaded(PackagesResponse response),
    @required Result error(String s),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result loading(),
    Result loaded(PackagesResponse response),
    Result error(String s),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageStateInit value),
    @required Result loading(PackageStateLoading value),
    @required Result loaded(PackageStateLoaded value),
    @required Result error(PackageStateError value),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageStateInit value),
    Result loading(PackageStateLoading value),
    Result loaded(PackageStateLoaded value),
    Result error(PackageStateError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class PackageStateLoading implements PackageState {
  const factory PackageStateLoading() = _$PackageStateLoading;
}

/// @nodoc
abstract class $PackageStateLoadedCopyWith<$Res> {
  factory $PackageStateLoadedCopyWith(
          PackageStateLoaded value, $Res Function(PackageStateLoaded) then) =
      _$PackageStateLoadedCopyWithImpl<$Res>;
  $Res call({PackagesResponse response});

  $PackagesResponseCopyWith<$Res> get response;
}

/// @nodoc
class _$PackageStateLoadedCopyWithImpl<$Res>
    extends _$PackageStateCopyWithImpl<$Res>
    implements $PackageStateLoadedCopyWith<$Res> {
  _$PackageStateLoadedCopyWithImpl(
      PackageStateLoaded _value, $Res Function(PackageStateLoaded) _then)
      : super(_value, (v) => _then(v as PackageStateLoaded));

  @override
  PackageStateLoaded get _value => super._value as PackageStateLoaded;

  @override
  $Res call({
    Object response = freezed,
  }) {
    return _then(PackageStateLoaded(
      response == freezed ? _value.response : response as PackagesResponse,
    ));
  }

  @override
  $PackagesResponseCopyWith<$Res> get response {
    if (_value.response == null) {
      return null;
    }
    return $PackagesResponseCopyWith<$Res>(_value.response, (value) {
      return _then(_value.copyWith(response: value));
    });
  }
}

/// @nodoc
class _$PackageStateLoaded
    with DiagnosticableTreeMixin
    implements PackageStateLoaded {
  const _$PackageStateLoaded(this.response) : assert(response != null);

  @override
  final PackagesResponse response;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageState.loaded(response: $response)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PackageState.loaded'))
      ..add(DiagnosticsProperty('response', response));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PackageStateLoaded &&
            (identical(other.response, response) ||
                const DeepCollectionEquality()
                    .equals(other.response, response)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(response);

  @override
  $PackageStateLoadedCopyWith<PackageStateLoaded> get copyWith =>
      _$PackageStateLoadedCopyWithImpl<PackageStateLoaded>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result loading(),
    @required Result loaded(PackagesResponse response),
    @required Result error(String s),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loaded(response);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result loading(),
    Result loaded(PackagesResponse response),
    Result error(String s),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loaded != null) {
      return loaded(response);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageStateInit value),
    @required Result loading(PackageStateLoading value),
    @required Result loaded(PackageStateLoaded value),
    @required Result error(PackageStateError value),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageStateInit value),
    Result loading(PackageStateLoading value),
    Result loaded(PackageStateLoaded value),
    Result error(PackageStateError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class PackageStateLoaded implements PackageState {
  const factory PackageStateLoaded(PackagesResponse response) =
      _$PackageStateLoaded;

  PackagesResponse get response;
  $PackageStateLoadedCopyWith<PackageStateLoaded> get copyWith;
}

/// @nodoc
abstract class $PackageStateErrorCopyWith<$Res> {
  factory $PackageStateErrorCopyWith(
          PackageStateError value, $Res Function(PackageStateError) then) =
      _$PackageStateErrorCopyWithImpl<$Res>;
  $Res call({String s});
}

/// @nodoc
class _$PackageStateErrorCopyWithImpl<$Res>
    extends _$PackageStateCopyWithImpl<$Res>
    implements $PackageStateErrorCopyWith<$Res> {
  _$PackageStateErrorCopyWithImpl(
      PackageStateError _value, $Res Function(PackageStateError) _then)
      : super(_value, (v) => _then(v as PackageStateError));

  @override
  PackageStateError get _value => super._value as PackageStateError;

  @override
  $Res call({
    Object s = freezed,
  }) {
    return _then(PackageStateError(
      s == freezed ? _value.s : s as String,
    ));
  }
}

/// @nodoc
class _$PackageStateError
    with DiagnosticableTreeMixin
    implements PackageStateError {
  const _$PackageStateError(this.s) : assert(s != null);

  @override
  final String s;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'PackageState.error(s: $s)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'PackageState.error'))
      ..add(DiagnosticsProperty('s', s));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is PackageStateError &&
            (identical(other.s, s) ||
                const DeepCollectionEquality().equals(other.s, s)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(s);

  @override
  $PackageStateErrorCopyWith<PackageStateError> get copyWith =>
      _$PackageStateErrorCopyWithImpl<PackageStateError>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result init(),
    @required Result loading(),
    @required Result loaded(PackagesResponse response),
    @required Result error(String s),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return error(s);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result init(),
    Result loading(),
    Result loaded(PackagesResponse response),
    Result error(String s),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(s);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result init(_PackageStateInit value),
    @required Result loading(PackageStateLoading value),
    @required Result loaded(PackageStateLoaded value),
    @required Result error(PackageStateError value),
  }) {
    assert(init != null);
    assert(loading != null);
    assert(loaded != null);
    assert(error != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result init(_PackageStateInit value),
    Result loading(PackageStateLoading value),
    Result loaded(PackageStateLoaded value),
    Result error(PackageStateError value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class PackageStateError implements PackageState {
  const factory PackageStateError(String s) = _$PackageStateError;

  String get s;
  $PackageStateErrorCopyWith<PackageStateError> get copyWith;
}
